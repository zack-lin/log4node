/**
 * Smoothie Charts - http://smoothiecharts.org/   v1.20
 */
!function (a) {
    function c(a) {
        this.options = b.extend({}, c.defaultOptions, a), this.data = [], this.maxValue = Number.NaN, this.minValue = Number.NaN
    }

    function d(a) {
        this.options = b.extend({}, d.defaultChartOptions, a), this.seriesSet = [], this.currentValueRange = 1, this.currentVisMinValue = 0, this.lastRenderTimeMillis = 0
    }

    var b = {extend: function () {
        var a, c;
        for (arguments[0] = arguments[0] || {}, a = 1; a < arguments.length; a++)for (c in arguments[a])arguments[a].hasOwnProperty(c) && (arguments[0][c] = "object" == typeof arguments[a][c] ? arguments[a][c]instanceof Array ? arguments[a][c] : b.extend(arguments[0][c], arguments[a][c]) : arguments[a][c]);
        return arguments[0]
    }};
    c.defaultOptions = {resetBoundsInterval: 3e3, resetBounds: !0}, c.prototype.resetBounds = function () {
        var a, b;
        if (this.data.length)for (this.maxValue = this.data[0][1], this.minValue = this.data[0][1], a = 1; a < this.data.length; a++)b = this.data[a][1], b > this.maxValue && (this.maxValue = b), b < this.minValue && (this.minValue = b); else this.maxValue = Number.NaN, this.minValue = Number.NaN
    }, c.prototype.append = function (a, b, c) {
        for (var d = this.data.length - 1; d > 0 && this.data[d][0] > a;)d--;
        this.data.length > 0 && this.data[d][0] === a ? c ? (this.data[d][1] += b, b = this.data[d][1]) : this.data[d][1] = b : d < this.data.length - 1 ? this.data.splice(d + 1, 0, [a, b]) : this.data.push([a, b]), this.maxValue = isNaN(this.maxValue) ? b : Math.max(this.maxValue, b), this.minValue = isNaN(this.minValue) ? b : Math.min(this.minValue, b)
    }, c.prototype.dropOldData = function (a, b) {
        for (var c = 0; this.data.length - c >= b && this.data[c + 1][0] < a;)c++;
        0 !== c && this.data.splice(0, c)
    }, d.defaultChartOptions = {millisPerPixel: 20, maxValueScale: 1, interpolation: "bezier", scaleSmoothing: .125, maxDataSetLength: 2, grid: {fillStyle: "#000000", strokeStyle: "#777777", lineWidth: 1, sharpLines: !1, millisPerLine: 1e3, verticalSections: 2, borderVisible: !0}, labels: {fillStyle: "#ffffff", disabled: !1, fontSize: 10, fontFamily: "monospace", precision: 2}, horizontalLines: []}, d.AnimateCompatibility = function () {
        var a = function (a, b) {
            var c = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (a) {
                return window.setTimeout(function () {
                    a((new Date).getTime())
                }, 16)
            };
            return c.call(window, a, b)
        }, b = function (a) {
            var b = window.cancelAnimationFrame || function (a) {
                clearTimeout(a)
            };
            return b.call(window, a)
        };
        return{requestAnimationFrame: a, cancelAnimationFrame: b}
    }(), d.defaultSeriesPresentationOptions = {lineWidth: 1, strokeStyle: "#ffffff"}, d.prototype.addTimeSeries = function (a, c) {
        this.seriesSet.push({timeSeries: a, options: b.extend({}, d.defaultSeriesPresentationOptions, c)}), a.options.resetBounds && a.options.resetBoundsInterval > 0 && (a.resetBoundsTimerId = setInterval(function () {
            a.resetBounds()
        }, a.options.resetBoundsInterval))
    }, d.prototype.removeTimeSeries = function (a) {
        var c, b = this.seriesSet.length;
        for (c = 0; b > c; c++)if (this.seriesSet[c].timeSeries === a) {
            this.seriesSet.splice(c, 1);
            break
        }
        a.resetBoundsTimerId && clearInterval(a.resetBoundsTimerId)
    }, d.prototype.getTimeSeriesOptions = function (a) {
        var c, b = this.seriesSet.length;
        for (c = 0; b > c; c++)if (this.seriesSet[c].timeSeries === a)return this.seriesSet[c].options
    }, d.prototype.bringToFront = function (a) {
        var c, d, b = this.seriesSet.length;
        for (c = 0; b > c; c++)if (this.seriesSet[c].timeSeries === a) {
            d = this.seriesSet.splice(c, 1), this.seriesSet.push(d[0]);
            break
        }
    }, d.prototype.streamTo = function (a, b) {
        this.canvas = a, this.delay = b, this.start()
    }, d.prototype.start = function () {
        if (!this.frame) {
            var a = function () {
                this.frame = d.AnimateCompatibility.requestAnimationFrame(function () {
                    this.render(), a()
                }.bind(this))
            }.bind(this);
            a()
        }
    }, d.prototype.stop = function () {
        this.frame && (d.AnimateCompatibility.cancelAnimationFrame(this.frame), delete this.frame)
    }, d.prototype.updateValueRange = function () {
        var d, e, f, g, h, i, a = this.options, b = Number.NaN, c = Number.NaN;
        for (d = 0; d < this.seriesSet.length; d++)e = this.seriesSet[d].timeSeries, isNaN(e.maxValue) || (b = isNaN(b) ? e.maxValue : Math.max(b, e.maxValue)), isNaN(e.minValue) || (c = isNaN(c) ? e.minValue : Math.min(c, e.minValue));
        null != a.maxValue ? b = a.maxValue : b *= a.maxValueScale, null != a.minValue && (c = a.minValue), this.options.yRangeFunction && (f = this.options.yRangeFunction({min: c, max: b}), c = f.min, b = f.max), isNaN(b) || isNaN(c) || (g = b - c, h = g - this.currentValueRange, i = c - this.currentVisMinValue, this.isAnimatingScale = Math.abs(h) > .1 || Math.abs(i) > .1, this.currentValueRange += a.scaleSmoothing * h, this.currentVisMinValue += a.scaleSmoothing * i), this.valueRange = {min: c, max: b}
    }, d.prototype.render = function (a, b) {
        var d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, c = (new Date).getTime();
        if (this.isAnimatingScale || (d = Math.min(1e3 / 6, this.options.millisPerPixel), !(c - this.lastRenderTimeMillis < d))) {
            if (this.lastRenderTimeMillis = c, a = a || this.canvas, b = b || c - (this.delay || 0), b -= b % this.options.millisPerPixel, e = a.getContext("2d"), f = this.options, g = {top: 0, left: 0, width: a.clientWidth, height: a.clientHeight}, h = b - g.width * f.millisPerPixel, i = function (a) {
                var b = a - this.currentVisMinValue;
                return 0 === this.currentValueRange ? g.height : g.height - Math.round(b / this.currentValueRange * g.height)
            }.bind(this), j = function (a) {
                return Math.round(g.width - (b - a) / f.millisPerPixel)
            }, this.updateValueRange(), e.font = f.labels.fontSize + "px " + f.labels.fontFamily, e.save(), e.translate(g.left, g.top), e.beginPath(), e.rect(0, 0, g.width, g.height), e.clip(), e.save(), e.fillStyle = f.grid.fillStyle, e.clearRect(0, 0, g.width, g.height), e.fillRect(0, 0, g.width, g.height), e.restore(), e.save(), e.lineWidth = f.grid.lineWidth, e.strokeStyle = f.grid.strokeStyle, f.grid.millisPerLine > 0)for (k = g.width - e.measureText(G).width + 4, l = b - b % f.grid.millisPerLine; l >= h; l -= f.grid.millisPerLine)m = j(l), f.grid.sharpLines && (m -= .5), e.beginPath(), e.moveTo(m, 0), e.lineTo(m, g.height), e.stroke(), e.closePath(), f.timestampFormatter && k > m && (n = new Date(l), o = f.timestampFormatter(n), p = e.measureText(o).width, k = m - p - 2, e.fillStyle = f.labels.fillStyle, e.fillText(o, m - p, g.height - 2));
            for (q = 1; q < f.grid.verticalSections; q++)r = Math.round(q * g.height / f.grid.verticalSections), f.grid.sharpLines && (r -= .5), e.beginPath(), e.moveTo(0, r), e.lineTo(g.width, r), e.stroke(), e.closePath();
            if (f.grid.borderVisible && (e.beginPath(), e.strokeRect(0, 0, g.width, g.height), e.closePath()), e.restore(), f.horizontalLines && f.horizontalLines.length)for (s = 0; s < f.horizontalLines.length; s++)t = f.horizontalLines[s], u = Math.round(i(t.value)) - .5, e.strokeStyle = t.color || "#ffffff", e.lineWidth = t.lineWidth || 1, e.beginPath(), e.moveTo(0, u), e.lineTo(g.width, u), e.stroke(), e.closePath();
            for (v = 0; v < this.seriesSet.length; v++) {
                for (e.save(), w = this.seriesSet[v].timeSeries, x = w.data, y = this.seriesSet[v].options, w.dropOldData(h, f.maxDataSetLength), e.lineWidth = y.lineWidth, e.strokeStyle = y.strokeStyle, e.beginPath(), z = 0, A = 0, B = 0, C = 0; C < x.length && 1 !== x.length; C++) {
                    if (D = j(x[C][0]), E = i(x[C][1]), 0 === C)z = D, e.moveTo(D, E); else switch (f.interpolation) {
                        case"linear":
                        case"line":
                            e.lineTo(D, E);
                            break;
                        case"bezier":
                        default:
                            e.bezierCurveTo(Math.round((A + D) / 2), B, Math.round(A + D) / 2, E, D, E)
                    }
                    A = D, B = E
                }
                x.length > 1 && (y.fillStyle && (e.lineTo(g.width + y.lineWidth + 1, B), e.lineTo(g.width + y.lineWidth + 1, g.height + y.lineWidth + 1), e.lineTo(z, g.height + y.lineWidth), e.fillStyle = y.fillStyle, e.fill()), y.strokeStyle && "none" !== y.strokeStyle && e.stroke(), e.closePath()), e.restore()
            }
            f.labels.disabled || isNaN(this.valueRange.min) || isNaN(this.valueRange.max) || (F = parseFloat(this.valueRange.max).toFixed(f.labels.precision), G = parseFloat(this.valueRange.min).toFixed(f.labels.precision), e.fillStyle = f.labels.fillStyle, e.fillText(F, g.width - e.measureText(F).width - 2, f.labels.fontSize), e.fillText(G, g.width - e.measureText(G).width - 2, g.height - 2)), e.restore()
        }
    }, d.timeFormatter = function (a) {
        function b(a) {
            return(10 > a ? "0" : "") + a
        }

        return b(a.getHours()) + ":" + b(a.getMinutes()) + ":" + b(a.getSeconds())
    }, a.TimeSeries = c, a.SmoothieChart = d
}("undefined" == typeof exports ? this : exports);